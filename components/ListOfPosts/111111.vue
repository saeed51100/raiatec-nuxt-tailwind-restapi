<template>
  <div>
    <div v-for="post in posts" :key="post.id">
      <!-- show post.title if exists in concatenatedTitles else execute new logic -->
      <template v-if="concatenatedTitles.includes(post.title.rendered)">
        <nuxt-link :to="`/${post.slug}`" @click="$emit('close-modal')" :key="post.slug">
          {{ post.title.rendered }}
        </nuxt-link>
      </template>
      <template v-else>
        <!-- categorized posts -->
        <div v-for="category in categories" :key="category.id">
          <template v-if="post.categories.includes(category.id) && !isCategoryRepeated(category.name)">
            <h3 class="bg-red-200">{{ category.name }}</h3>
            <ul>
              <li v-for="relatedPost in category.posts.slice().reverse()" :key="relatedPost.id">
                <nuxt-link :to="`/${relatedPost.slug}`" @click="$emit('close-modal')" :key="relatedPost.slug">
                  {{ relatedPost.title.rendered }}
                </nuxt-link>
              </li>
            </ul>
          </template>
        </div>
      </template>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, watch } from 'vue';
import useWpApi from '~/composables/useWpApi';

// Define the setup function as async to use asyncData
export default async function setup() {
  // Fetch posts and categories using asyncData
  const { data: posts } = await useWpApi().getPosts();
  const { data: categories } = await useWpApi().getCategories();

  const nonCategorizedPosts = computed(() => {
    return posts.value?.filter(post => !post.categories.length);
  });

  categories.value.forEach(category => {
    category.posts = posts.value?.filter(post =>
        post.categories.includes(category.id)
    );
  });

  // Initialize an array to store concatenated titles
  const concatenatedTitles = ref([]);

  // Add post titles into the 'concatenatedTitles' array
  nonCategorizedPosts.value?.forEach((post) => {
    concatenatedTitles.value.push(post.title.rendered);
  });

  // Watch for changes to the post title
  watch(
      () => posts.value,
      () => {
        // Update the concatenated titles array
        concatenatedTitles.value = [];
        nonCategorizedPosts.value?.forEach((post) => {
          concatenatedTitles.value.push(post.title.rendered);
        });
      }
  );

  // Computed property to check if category name is repeated
  const isCategoryRepeated = computed(() => {
    const uniqueCategories = new Set();
    return (categoryName: string) => {
      if (uniqueCategories.has(categoryName)) {
        return true; // Category name is repeated
      } else {
        uniqueCategories.add(categoryName);
        return false; // Category name is not repeated
      }
    };
  });

  // Return the data and computed properties
  return {
    posts,
    categories,
    concatenatedTitles,
    isCategoryRepeated,
  };
}

// Use asyncData to fetch data before rendering the page
export async function asyncData() {
  const { data: posts } = await useWpApi().getPosts();
  const { data: categories } = await useWpApi().getCategories();

  return {
    posts,
    categories,
  };
}
</script>
